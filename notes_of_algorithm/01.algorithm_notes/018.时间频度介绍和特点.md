<!-- TOC -->

- [1. 时间频度](#1-时间频度)
  - [1.1. 度量程序执行时间的两种方法](#11-度量程序执行时间的两种方法)
    - [1.1.1. 事后统计的方法](#111-事后统计的方法)
    - [1.1.2. 事前估算的方法](#112-事前估算的方法)
  - [1.2. 时间频度](#12-时间频度)
    - [1.2.1. 基本介绍](#121-基本介绍)
    - [1.2.2. 实例说明](#122-实例说明)
    - [1.2.3. 可忽略常数项](#123-可忽略常数项)
    - [1.2.4. 可忽略低次项](#124-可忽略低次项)
    - [1.2.5. 可忽略系数](#125-可忽略系数)

<!-- /TOC -->

****
[博主的 Github 地址](https://github.com/leon9dragon)
****

## 1. 时间频度

### 1.1. 度量程序执行时间的两种方法

#### 1.1.1. 事后统计的方法
方法可行, 但存在两个缺陷:  
- 要对设计的算法的运行性能进行评估, 需要实际运行程序
- 所得时间的统计量依赖于计算机的软硬件等环境因素

#### 1.1.2. 事前估算的方法
通过分析某个算法的时间复杂度来判断哪个算法更优

****

### 1.2. 时间频度

#### 1.2.1. 基本介绍
- 一个算法的时间与算法中的语句执行次数成正比  
  哪个算法中语句执行次数多, 它花费时间就越多

- 算法中的语句执行次数称为语句频度或时间频度, 记为 T(n)

#### 1.2.2. 实例说明
拿计算 1-100 所有数字之和进行示范, 设计了两种算法  
- **第一种算法**  
- 它的时间频度是 T(n) = n+1  
  因为循环语句要执行 n+1 次, 多出的一次是判断跳出循环.  

```java
    int total = 0;
    int end = 100;
    //用for循环计算
    for(int i = 1; i < end; i++){
        total += i;
    }
```

- **第二种算法**
- 它的时间频度 T(n) = 1, 它只需要执行一条语句

```java
    int total = 0;
    int end = 100;
    total = (1 + end) * end / 2
```

#### 1.2.3. 可忽略常数项
- 在一些情况下计算时间频度可以忽略常数项

**举例:**  
- T(2n+20) 和 T(2n) 随着 n 变大, 执行曲线无限接近, 20 可以忽略
- T(3n+10) 和 T(3n) 随着 n 变大, 执行曲线无限接近, 10 可以忽略

#### 1.2.4. 可忽略低次项
- 在一些情况下计算时间频度可以忽略低次项

**举例:**  
- T(2n<sup>2</sup>+3n+10) 与 T(2n<sup>2</sup>) 在执行曲线上无限接近, 低次项可以忽略
- T(n<sup>2</sup>+5n+20) 与 T(n<sup>2</sup>) 在执行曲线上无限接近, 低次项可以忽略

#### 1.2.5. 可忽略系数
- 在一些情况下计算时间频度可以忽略系数

**举例:**  
- 随着 n 值变大, 5n<sup>2</sup>+7n 和 3n<sup>2</sup>+2n 的之性曲线重合, 这种情况下系数可忽略
- 但是 n<sup>3</sup>+5n 和 6n<sup>3</sup>+4n 执行曲线分离, 因此次数是关键