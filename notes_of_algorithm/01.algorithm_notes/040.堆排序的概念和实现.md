<!-- TOC -->

- [1. 堆的概念](#1-堆的概念)
  - [1.1. 基本介绍](#11-基本介绍)
    - [1.1.1. 大顶堆图示](#111-大顶堆图示)
    - [1.1.2. 小顶堆图示](#112-小顶堆图示)
- [2. 堆排序的概念](#2-堆排序的概念)
  - [2.1. 基本介绍](#21-基本介绍)
  - [2.2. 基本思想](#22-基本思想)
  - [2.3. 步骤图解](#23-步骤图解)
    - [2.3.1. 将无序序列转换成大顶堆](#231-将无序序列转换成大顶堆)
    - [2.3.2. 反复构建大顶堆得出有序序列](#232-反复构建大顶堆得出有序序列)
- [3. 堆排序的代码实现](#3-堆排序的代码实现)
  - [3.1. 排序代码](#31-排序代码)
  - [3.2. 测试结果](#32-测试结果)

<!-- /TOC -->

****
[博主的 Github 地址](https://github.com/leon9dragon)
****

## 1. 堆的概念

### 1.1. 基本介绍
- 堆是具有特定结点性质的完全二叉树, 且分为大顶堆和小顶堆
- 每个结点的值大于或等于其子结点的值称为大顶堆
- 每个结点的值小于或等于其子结点的值称为小顶堆
- 大/小顶堆都没对结点的左右子结点的值有大小关系要求.
  </br></br>
- 一般升序采用大顶堆, 降序采用小顶堆

#### 1.1.1. 大顶堆图示
- 右下是对堆中结点按层进行编号, 然后映射到数组中的结果

![sample1](../99.images/2020-06-16-14-24-43.png)

- 大顶堆的特点:  
  `arr[i] >= arr[2*i+1] && arr[i] >= arr[2*i+2]`  
  其中 i 对应的是堆的结点编号, 即数组下标, 从 0 开始.

#### 1.1.2. 小顶堆图示
![sample2](../99.images/2020-06-16-15-16-16.png)

- 小顶堆的特点:  
  `arr[i] <= arr[2*i+1] && arr[i] <= arr[2*i+2]`  
  其中 i 对应的是堆的结点编号, 即数组下标, 从 0 开始.

****

## 2. 堆排序的概念

### 2.1. 基本介绍 
- 堆排序是利用堆这种数据结构而设计的一种排序算法, 是不稳定的排序.
- 堆排序是一种选择排序, 最坏/最好/平均时间复杂度均为 O(nlog<sub>2</sub>n)

### 2.2. 基本思想
1. 将待排序序列构造成一个大顶堆.(可用数组模拟树进行操作)
2. 构造完后的整个序列的最大值就是堆顶的根节点.
3. 将其与末尾元素进行交换, 此时末尾就为最大值.
4. 再将剩余 n-1 个元素重新构成一个堆, 这样会得到 n 个元素的次小值.  
5. 如此反复执行, 便能得到一个有序序列.

- 可以看到在构建大顶堆的过程中, 元素的个数逐渐减少,  
最终就能够得到一个有序序列.

### 2.3. 步骤图解
- 要求: 对数组 arr={4,6,8,5,9} 使用堆排序, 将数组升序排序

#### 2.3.1. 将无序序列转换成大顶堆
>- 将待排序序列构造成一个大顶堆.

1. 假设给定无序序列结构如下  
![step1](../99.images/2020-06-16-17-11-56.png)


2. 先从最后一个非叶子结点开始, 从左到右, 从上到下进行调整   
第一个非叶子结点计算公式为 `arr.length/2 - 1 = 1`, 即结点 6,  
由于 {6,5,9} 中 9 最大, 因此 6 和 9 进行交换.
![step2](../99.images/2020-06-16-17-17-52.png)

3. 找到倒数第二个非叶子结点 4, `arr.length/2 - 2 = 0`,  
   由于 {4,9,8} 中 9 最大, 因此 4 和 9 进行交换.  
   ![step3](../99.images/2020-06-16-17-31-21.png)

4. 这时, 交换导致了子根 {4,5,6} 结构混乱, 继续进行调整,  
   由于 {4,5,6} 中 6 最大, 因此 4 和 6 进行交换.  
   此时就已经完成将一个无序序列构成了一个大顶堆了.  
   ![step4](../99.images/2020-06-17-08-23-52.png)

#### 2.3.2. 反复构建大顶堆得出有序序列
>- 先将堆顶元素与末尾元素进行交换, 使末尾元素最大.  
>- 再对堆进行调整, 将堆顶元素与末尾元素交换, 得到第二大元素.  
>- 因为这一步只有根结点变化, 其它都符合大顶堆的定义,   
   所以可以以根结点为起点, 重新构建大顶堆, 即将根结点逐步下沉即可.
>- 如此反复进行交换, 重建, 交换, 最后得出有序序列.


1. 将堆顶元素 9 和末尾元素 4 进行交换
![step5](../99.images/2020-06-17-08-51-55.png)

2. 重新调整结构, 使其继续满足堆定义
![step6](../99.images/2020-06-17-08-53-19.png)

3. 再将堆顶元素 8 和末尾元素 5 进行交换, 得到第二大元素 8
![step7](../99.images/2020-06-17-08-55-01.png)

4. 后续过程, 继续进行调整, 交换, 如此往复进行, 最终使序列有序  
![step8](../99.images/2020-06-17-14-41-54.png)
   

****

## 3. 堆排序的代码实现

### 3.1. 排序代码
```java
package com.leo9.dc25.heap_sort;

import java.util.Arrays;

public class HeapSort {
    public static void main(String[] args) {
        int[] arr = {4, 6, 8, 5, 9,10,-22};
        System.out.println("=====beforeSort=====\n"+Arrays.toString(arr));
        heapSort(arr);
    }

    //编写一个堆排序方法
    public static void heapSort(int[] arr) {
        System.out.println("=====heapSort=====");
        for (int i = arr.length / 2 - 1; i >= 0; i--) {
            adjustHeap(arr, i, arr.length);
        }
        //先将堆顶元素与末尾元素进行交换, 使末尾元素最大.
        //再对堆进行调整, 将堆顶元素与末尾元素交换, 得到第二大元素.
        //如此反复进行交换, 重建, 交换, 最后得出有序序列.
        int temp = 0;
        for (int j = arr.length - 1; j > 0; j--) {
            //交换
            temp = arr[j];
            arr[j] = arr[0];
            arr[0] = temp;
            //将数组的前length-1位再进行排序
            adjustHeap(arr, 0, j);
        }

        //输出排序后的数组
        System.out.println(Arrays.toString(arr));
    }

    //将数组(二叉树)调整成一个大顶堆

    /**
     * @param arr    待调整数组
     * @param i      非叶子结点在数组中索引
     * @param length 需要调整的元素个数
     */
    public static void adjustHeap(int[] arr, int i, int length) {
        //先取出当前元素的值, 保存在临时变量
        int temp = arr[i];
        //开始调整, k一开始指向的是i的左子结点
        for (int k = i * 2 + 1; k < length; k = k * 2 + 1) {
            if (k + 1 < length && arr[k] < arr[k + 1]) {
                //如果左子结点的值小于右子结点的值
                //k就指向右子结点
                k++;
            }
            if (arr[k] > temp) {
                //如果k所指向的子结点的值大于父结点
                //将较大的值向上移动, 同时改变i的指向
                arr[i] = arr[k];
                i = k;
            } else {
                break;
            }
        }
        //当for循环结束后, 已经把以i为父结点的树的最大值, 放在了最顶上
        //将temp的值放到调整后的位置
        arr[i] = temp;
    }
}

```

### 3.2. 测试结果
- 显而易见, 排序结果正确  
![res](../99.images/2020-06-21-23-28-34.png)

- 堆排序的速度非常快, 800 万数据大约耗时 3 秒