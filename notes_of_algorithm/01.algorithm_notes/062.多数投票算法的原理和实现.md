<!-- TOC -->

- [1. 多数投票算法的原理](#1-多数投票算法的原理)
  - [1.1. 应用场景](#11-应用场景)
  - [1.2. 简单解法](#12-简单解法)
  - [1.3. 多数投票算法的基本介绍](#13-多数投票算法的基本介绍)
  - [1.4. 算法实现](#14-算法实现)

<!-- /TOC -->

****
[博主的 Github 地址](https://github.com/leon9dragon)
****

## 1. 多数投票算法的原理

### 1.1. 应用场景
假设我们有一个无序的数组, 我们想知道当前数组中是否存在出现次数大于等于数组元素的一半的元素,  
如果存在这样的元素, 该元素值是多少, 如何以高效的算法来完成此任务.

### 1.2. 简单解法  
简单的解法就是先对数组进行排序, 如果存在这样的一个数, 那么中间值一定是该数,  
为了确认该数出现次数大于等于数组元素的一半, 需要再次遍历整个数组并保存该数出现的次数.  
由于排序, 该解法的时间复杂度为 O(nlgn).

### 1.3. 多数投票算法的基本介绍
Boyer-Moore Algorithm 算法为多数表决算法, 可参考论文 http://www.cs.rug.nl/~wim/pub/whh348.pdf,  
该算法使用 O(1) 的时间复杂度和 O(n) 的空间复杂度来解决该问题, 它使用两次遍历数组.  
第一次遍历找出一个候选元素, 这里变种就是有多个候选元素, 第二遍只计算候选元素在数组中出现的次数以确认该元素(或所有候选元素)是否为最后答案.  
在第一次遍历中, 我们需要两个变量: 
- 一个candidate变量, 初始化为任意值;
- 一个count变量, 初始化为0;  

遍历数组的每一个元素, 首先判断 count 的值, 如果 count 值为 0,  
就设置 candidate 的值为当前元素, 接下来比较当前元素的值是否和 candidate 相等,  
如果相等 count 自增 1, 否则 count 减小 1. 

### 1.4. 算法实现
```java
class Solution {
    public int majorityElement(int[] nums) {
        int count = 0, ret = 0;
        for (int num : nums) {
            if (count == 0)
                ret = num;
            if (num != ret)
                count--;
            else
                count++;
        }
        return ret;
    }
}
```