<!-- TOC -->

- [1. 包装流的概念](#1-包装流的概念)
- [2. 缓冲流](#2-缓冲流)
  - [2.1. 缓冲流的概述](#21-缓冲流的概述)
    - [2.1.1. 缓冲流读取文件的过程](#211-缓冲流读取文件的过程)
  - [2.2. 字节缓冲流](#22-字节缓冲流)
    - [2.2.1. 字节输入缓冲流常用构造器](#221-字节输入缓冲流常用构造器)
    - [2.2.2. 字节输出缓冲流常用构造器](#222-字节输出缓冲流常用构造器)
    - [2.2.3. 用法实例](#223-用法实例)
  - [2.3. 字符缓冲流](#23-字符缓冲流)
    - [2.3.1. 输入流增强的方法](#231-输入流增强的方法)
    - [2.3.2. 输出流增强的方法](#232-输出流增强的方法)

<!-- /TOC -->

## 1. 包装流的概念
- 处理流/包装流(相对于节点流更高级):  
  - 隐藏了底层的节点流的差异, 并对外提供了更方便的输入/输出功能,   
    让开发者只需要关注高级流的操作, 是对字节流的一种增强操作.
  - 使用处理流包装了节点流程序直接操作处理流, 让节点流与底层的设备做 io 操作.
  - 只需要关闭处理流即可.

- 包装流如何区分:  
  在创建流对象的时候需要传递另一个流对象, 这种流对象就是包装流对象.  
  例如: `new包装流(流对象);`

****

## 2. 缓冲流

### 2.1. 缓冲流的概述
- 是一个包装流, 目的起缓存作用, 缓冲流还能优化 io 效率, 使速度提升.  
  因此操作字节或字符流的时候, 都建议使用缓冲流进行包装, 提高运行效率.

- 缓冲流一共有四种:
  - `BufferedInputStream`
  - `BufferedOutputStream`
  - `BufferedReader`
  - `BufferedWriter`

- 直接操作的缺陷:  
  操作流的时候习惯定义一个 `byte/char` 数组.  
  `int read()` 方法每次都从磁盘文件中读取一个字节.  
  这样直接操作磁盘文件性能极低.  

- 解决方案:  
  定义一个数组作为缓冲区. 例如 `byte[] buffer = new byte[1024];`   
  一次性从磁盘文件中读取 1024 个字节并放入缓冲区中.  
  这样会减少操作磁盘文件次数, 程序性能得以提升.    
  因此在 JAVA 中所提供的缓存区默认大小是 8192byte.  

#### 2.1.1. 缓冲流读取文件的过程
- 读取文件的流程和写入文件流程相似, 假定现在是读取操作
  - 首先输入缓冲流定义了大小为 8092 字节的缓冲区, 然后一次从文件中读取 8092 字节
  - 当缓冲区存放够了 8092 个字节的数据后, 就会进行数据转移, 从内存转移到程序中去
  - 转移过程会使用字节输入流并根据用户定义的字节数组, 分批将这些字节数据进行转移.


- 下一步进行写入操作, 那么又会再次分批次将字节存入输出缓冲流的缓冲区中
  - 转移过程会使用到字节输入流来从内存获取数据, 并分批转移到缓冲区中进行存放
  - 当输出缓冲流的缓冲区存满或不再被写入的时候, 就将缓冲区内容一次转移到文件中去.

****

### 2.2. 字节缓冲流
- `BufferedInputStream` 字节缓冲输入流
  - `BufferedInputStream` 为另一个输入流添加一些功能,  
    即缓冲输入以及支持 `mark` 和 `reset` 方法的能力.

- `BufferedOutputStream` 字节缓冲输出流
  - 该类实现缓冲的输出流. 通过设置这种输出流, 程序就可将各个字节写入底层输出流中,  
    而不必针对每次字节写入调用底层系统

#### 2.2.1. 字节输入缓冲流常用构造器
- `BufferedInputStream(InputStream in)`
  - 作用:  
    创建一个 `BufferedInputStream` 并保存其参数, 即输入流 `in`, 以便将来使用.

#### 2.2.2. 字节输出缓冲流常用构造器
- `BufferedOutputStream(OutputStream out)`
  - 作用:  
    创建一个新的缓冲输出流, 以将数据写入指定的底层输出流.

#### 2.2.3. 用法实例
- 实际上和其它的输入输出流用法相仿, 但提高了性能.
```java
public static void main (String[] args) throws Exception{
    //字节缓冲输出流
    BufferedOutputStream bos = new BufferedOutputStream (new FileOutputStream("stream.txt"，true));
    bos.write("hello world".getBytes());
    bos.close();
    
    //字节缓冲输入流
    BufferedInputStream bin = new BufferedInputStream(new FileInputStream("stream.txt"));
    byte[] buffer = new byte[1024];
    int len = -1;
    while((len = bin.read(buffer)) != -1){
        System.out.println(new String(buffer, 0，len)) ;
    )
    bin.close();
}
```

****

### 2.3. 字符缓冲流
- `BufferedReader` 字符缓冲输入流
- `BufferedWriter` 字符缓冲输出流
- 在使用上和字节缓冲流相似.

#### 2.3.1. 输入流增强的方法
- `String readLine()`  
  - 作用:  
    读取一个文本行.

#### 2.3.2. 输出流增强的方法
- `void newLine()`  
  - 作用:  
    写入一个行分隔符.