<!-- TOC -->

- [1. 接口的基础要点](#1-接口的基础要点)
  - [1.1. 接口的概念](#11-接口的概念)
  - [1.2. 接口的定义使用](#12-接口的定义使用)
    - [1.2.1. 定义](#121-定义)
    - [1.2.2. 语法](#122-语法)
    - [1.2.3. 起名规范](#123-起名规范)
    - [1.2.4. 接口存在的成员](#124-接口存在的成员)
    - [1.2.5. 备注](#125-备注)
  - [1.3. 接口的使用方式](#13-接口的使用方式)
    - [1.3.1. 标志接口:](#131-标志接口)
    - [1.3.2. 常量接口:](#132-常量接口)
- [2. 接口的补充要点](#2-接口的补充要点)
  - [2.1. 接口的特点](#21-接口的特点)
  - [2.2. 接口和接口/接口和类间的关系](#22-接口和接口接口和类间的关系)
  - [2.3. 接口的实现关系](#23-接口的实现关系)
- [3. 接口和抽象类的异同](#3-接口和抽象类的异同)
  - [3.1. 接口和抽象类的共同点](#31-接口和抽象类的共同点)
  - [3.2. 接口和抽象类的区别](#32-接口和抽象类的区别)
- [4. 面向接口编程的好处](#4-面向接口编程的好处)

<!-- /TOC -->

## 1. 接口的基础要点

### 1.1. 接口的概念
- 一种特殊的类, 表示一种规范, 是具有的 N 个方法的特征集合.
- 接口表示一种规范/约束/要求实现这必须遵循该规范.
- 接口只定义了类应当遵循的规范,  
  却不关心这些类的内部数据和其功能的实现细节.
- 站在程序的角度上说, 接口只规定了类里必须提供的方法,  
  从而分离了规范和实现, 增强了系统的可拓展性和可维护性.

### 1.2. 接口的定义使用

#### 1.2.1. 定义  
  - Java 中最小的程序单元就是类, 接口其实是一个特殊的类.
  - Java 中的接口表示规范, 用于定义一组抽象方法,   
    表示某一类事物必须具备的功能, 要求实现类必须来实现其功能  

#### 1.2.2. 语法  
  ```java
  [public] interface 接口名{
      //定义接口内容
  }
  ```

#### 1.2.3. 起名规范  
  表示具有某些能力的, 有人习惯以 -able/handler 结尾.  
  也有的人习惯以 i- 开头进行起名.

#### 1.2.4. 接口存在的成员  
  - 接口中没有构造器, 因此接口不能创建实例对象
  - 接口中定义的成员变量, 实质上是全局静态常量,  
    默认是使用 `public static final` 修饰.
  - 接口中定义的方法都是公共的抽象方法,  
    默认是使用 `public abstract` 修饰.  
    接口中不允许定义普通方法.
  - 接口中定义的内部类都是公共的静态内部类  
    默认是使用 `public static` 修饰.

#### 1.2.5. 备注  
  - 接口编译成功后, 会和类一样, 产生一份字节码,  
  一个接口产生一份字节码.    
  - java8 之后, 接口可以存在普通方法, 且有方法体.

### 1.3. 接口的使用方式

#### 1.3.1. 标志接口:  
  接口中没有任何成员, 仅仅只是一个接口的定义, 用作标志识别  
  其它的类实现该接口, 就属于该家族,  
  可以通过第三方代码赋予该接口实现类特殊的功能

#### 1.3.2. 常量接口:  
  有人喜欢使用接口来封装多个常量信息, 其目的和常量类相同.


## 2. 接口的补充要点

### 2.1. 接口的特点
1. 没有构造方法, 不能实例化
2. 接口只能继承接口, 不能继承类, 且接口支持多继承  
   示例:  
   `[修饰符] interface 接口名 extends 接口1, 接口2`
3. 接口里的方法全是抽象的,  
   默认修饰符是 `public abstract`
4. 接口里的字段全是全局静态常量,  
   默认修饰符是 `public static final`
5. 接口里的内部类全是静态的,  
   默认修饰符是 `public static`

### 2.2. 接口和接口/接口和类间的关系
- 接口和接口之间只能是继承关系, 用 `extends` 来表示
- 接口和实现类之间只能是实现关系, 用 `implements` 来表示  
  且一个类可以实现多个接口, 弥补了类只能单继承的问题.
  示例:  
```java
   [修饰符] class 类名 extends 父类 implements 接口1, 接口2{
      //实现类的实现内容
   }
```
- 因此可以认为接口是实现类的父类, 实现类就是接口的子类  
- 因此 `接口 变量 = new 实现类对象` 则体现了多态思想  
- 接口和实现类的多态关系是使用的最多的

### 2.3. 接口的实现关系
- **接口的实现者: 实现类**
  - 接口仅仅只定义了某一类事物应该具有某些功能, 但没有提供实现
  - 接口需要用户去提供实现类去覆盖接口中的方法, 从而实现接口所规定的功能
  - 注意:  
    - 接口中的方法是公共抽象的, 所以实现类必须覆盖接口中的方法,  
    并且方法必须使用 `public` 修饰,   
    因为子类覆盖的访问权限必须大于等于父类
    - 若一个类同时实现了多个接口, 如下:  
      用什么接口来实例化实现类对象, 只能调用该接口下存在的方法
      若是想要调用该类实现的全部方法, 只能用本类来实例化对象
      ```java
      public interface Meat{
         void getMeat();
      }
      public interface Vegetable{
         void getVegetable();
      }
      public class Food implements Meat, Vegetable{
         public void getMeat(){
            System.out.println("Get some meat");
         }
         public void getVegetable(){
            System.out.println("Get some vegetable");
         }
      }
      public class TestDemo{
         public static void main(String args[]){
            /*-------------------------*/
            Meat m = new Food();
            m.getMeat();
            /*-------------------------*/
            Vegetable v = new Food();
            v.getVegetable();
            /*-------------------------*/
            Food f = new Food();
            f.getMeat();
            f.getVegetable();
         }
      }
      ```
****

## 3. 接口和抽象类的异同

### 3.1. 接口和抽象类的共同点
1. 都位于继承的顶端, 用于被其他类实现或继承.
2. 都不能实例化.
3. 都可以定义抽象方法, 其子类/实现类都必须覆盖这些抽象方法.

### 3.2. 接口和抽象类的区别
1. 接口没有构造方法, 抽象类有构造方法.

2. 抽象类可以包含普通方法和抽象方法,  
   接口只能包含抽象方法(java8 后可以包含普通方法)

3. 一个类只能继承一个直接父类(可能是抽象类),  
   但可以实现多个接口(接口弥补了 java 的单继承)

4. 变量:  
   接口中默认是 `public static final` 修饰,  
   抽象类默认是包访问权限

5. 方法:  
   接口中默认是 `public abstract` 修饰,  
   抽象类默认是包访问权限

6. 内部类:  
   接口中默认是 `public static` 修饰,  
   抽象类默认是包访问权限

****

## 4. 面向接口编程的好处  
- 如果接口和抽象类可以完成相同的功能, 尽量使用接口,  
   做到面向接口编程

- 最大的好处在于运用到了多态:  
  - 把实现类对象赋给接口类型变量, 屏蔽了不同实现类间的实现差异,   
  从而做到通用编程.