<!-- TOC -->

- [1. 内部类](#1-内部类)
  - [1.1. 内部类的好处](#11-内部类的好处)
  - [1.2. 内部类的分类](#12-内部类的分类)
    - [1.2.1. 实例内部类:](#121-实例内部类)
    - [1.2.2. 静态内部类:](#122-静态内部类)
    - [1.2.3. 局部内部类:](#123-局部内部类)
    - [1.2.4. 匿名内部类](#124-匿名内部类)
  - [1.3. 内部类的修饰符](#13-内部类的修饰符)
  - [1.4. 内部类的名称](#14-内部类的名称)
- [2. 实例内部类](#2-实例内部类)
  - [2.1. 实例内部类的特点:](#21-实例内部类的特点)
  - [2.2. 实例内部类调用流程](#22-实例内部类调用流程)
- [3. 静态内部类](#3-静态内部类)
  - [3.1. 静态内部类的特点](#31-静态内部类的特点)
- [4. 局部内部类](#4-局部内部类)
- [5. 匿名内部类](#5-匿名内部类)

<!-- /TOC -->

## 1. 内部类
- 定义在类结构中的另一个类称之为内部类

### 1.1. 内部类的好处
1. 增强封装, 把内部类隐藏在外部类之内, 不需其他类访问该类
2. 内部类能提高代码的可读性和可维护性, 把小型类嵌入到外部类中结构上代码更靠近
3. 内部类可以直接访问外部类成员

### 1.2. 内部类的分类
- 内部类根据使用不同的修饰符或者定位的位置不同, 分为四类:

#### 1.2.1. 实例内部类:  
- 内部类没有使用 static 修饰

#### 1.2.2. 静态内部类:  
- 内部类使用了 static 修饰

#### 1.2.3. 局部内部类:  
- 在方法中定义的内部类

#### 1.2.4. 匿名内部类
- 适合只使用一次的类  

### 1.3. 内部类的修饰符
内部类算是外部类的一个成员, 类似于字段,  
因此内部类可以使用缺省/public/protected/private 修饰,  
还可以使用 static 修饰.

### 1.4. 内部类的名称
- 对于每个内部类来说, java 编译器会生成独立的字节码文件
- 而内部类的字节码的名称根据分类则有以下特征
1. 成员内部类: `外部类名$内部类名字`
2. 局部内部类: `外部类名$数字$内部类名称`
3. 匿名内部类: `外部类名$数字`

****

## 2. 实例内部类
- **没有使用 static 修饰的内部类**
  - 说明内部类属于外部类的实例成员, 即只有对象才能调用    
    并不属于外部类本身.

### 2.1. 实例内部类的特点:  
1. 创建实例内部类前, 必须存在外部类对象,  
   通过外部类对象创建内部类对象,  
   当存在内部类对象时, 一定存在外部类对象.

2. 实例内部类的实例自动持有外部类的实例的引用,   
   内部类可以直接访问外部类成员

3. 外部类中不能直接访问内部类的成员,  
   必须通过内部类的实例进行访问

4. 实例内部类中不能定义静态成员, 只能定义实例成员

5. 如果实例内部类和外部类存在同名的字段或方法,  
   如该方法名叫 xxxMethod, 则在内部类中:  
   - `this.xxxMethod` 表示访问内部类成员
   - `外部类.this.xxxMethod` 表示访问外部类成员
  
### 2.2. 实例内部类调用流程
0. 示例外部类和内部类
   ```java
   public class Outer{
      public class Inner{

      }
   }
   ```

1. 创建实例内部类对象  
   因实例内部类属于实例成员, 所以需要有实例成员才能调用  
   因此在创建内部类对象时需要通过如下方式创建:   
   - 实例内部类的类名需要通过 `外部类.内部类` 来调用
   - 实例内部类的构造函数需要通过 `外部类对象.new 内部类构造器` 来调用
   ```java
   public class Test{
      public static void main(String args[]){
         //先创建外部类对象
         Outer out_obj = new Outer();
         //创建内部类对象
         Outer.Inner in_obj = out_obj.new Inner();
      }
   }
   ```


## 3. 静态内部类
- **使用 static 修饰的内部类**
  - 说明内部类属于外部类本身, 通过外部类的类名调用

### 3.1. 静态内部类的特点
1. 静态内部类的实例不会自动持有外部类的特定实例的引用  
   在创建内部类的实例时, 不必创建外部类的实例.  
   示例:  
   ```java
   public class Outer{
      public static class Inner{

      }
   }
   public class Test{
      public static void main(String args[]){
         //创建内部类对象
         Outer.Inner in_obj = new Outer.Inner();
      }
   }
   ```

2. 静态内部类可以直接访问外部类的静态成员,    
   如果访问外部类的实例成员, 必须通过外部类的实例去访问

3. 在静态内部类中可以定义静态成员和实例成员

4. 测试类可以通过完整的类名直接访问静态内部类的静态成员

****

## 4. 局部内部类
- **在方法中定义的内部类, 其可见范围是当前方法, 相当于是局部变量**
1. 不能使用 `public, private, protected, static` 修饰符

2. 局部内部类只能在当前方法中使用

3. 局部内部类和实例内部类一样, 不能包含静态成员

4. 局部内部类和实例内部类, 可以访问外部类的所有成员

5. 局部内部类访问的局部变量必须用 `final` 修饰  
   (java8 中会隐式加上 `final`, 但依然是常量, 不能改变值)  
   原因:  
   如果当前方法不是 `main` 方法, 那么方法调用完毕后,  
   当前方法的栈帧会被销毁, 方法内部的局部变量的空间全部销毁.   
   然而局部内部类是定义在方法中的, 且在方法中会创建局部内部类对象,  
   而局部内部类会访问局部变量, 在当前方法被销毁的时候,  
   对象还在堆内存, 依然持有对局部变量的引用,  
   但是方法被销毁的时候, 局部变量已经被销毁了,  
   此时在堆内存中一个对象引用着一个不存在的数据,  
   为了避免该问题, 使用 `final` 修饰局部变量, 使其变成常量,  
   让该常量永驻内存空间中, 即使方法销毁后, 该局部变量也存在内存中,  
   对象可以继续持有.  


## 5. 匿名内部类
- **适合只使用一次的类, 是一个没有名称的局部内部类**

1. 匿名内部类本身没有构造器, 但是会调用父类的构造器.

2. 匿名类尽管没有构造器, 但是可以在匿名类中提供一段实例初始化代码,  
   JVM 在调用父类构造器后, 会执行该段代码.

3. 内部类除了可以继承之外, 还可以实现接口   
   
- 格式:    
```java
new 父类构造器([实参列表]) 或 接口()
{
    //匿名内部类的类体部分
}
```
- 注意:  
  - 匿名内部类必须继承一个父类或者实现一个接口,  
    但最多只能继承一个父类或实现一个接口.
  - 匿名内部类访问外部变量也需要加 `final` 修饰

- 用途:  
  在 JavaSE/Android 事件处理中(如按钮事件),  
  不同的按钮点击之后, 要有不同的响应操作,  
  这些响应操作只需要在按钮被点击的时候执行一次,  
  不需要专门为其再写一个类文件,    
  因此首选匿名内部类且更多用的是匿名内部类实现接口.  