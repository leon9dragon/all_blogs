<!-- TOC -->

- [1. 包装类的概念](#1-包装类的概念)
  - [1.1. 包装类的由来](#11-包装类的由来)
  - [1.2. 基本数据类型及其包装类](#12-基本数据类型及其包装类)
  - [1.3. 装箱和拆箱操作](#13-装箱和拆箱操作)
    - [1.3.1. 装箱操作:](#131-装箱操作)
    - [1.3.2. 拆箱操作:](#132-拆箱操作)
  - [1.4. 自动装箱和自动拆箱](#14-自动装箱和自动拆箱)
    - [1.4.1. 自动装箱:](#141-自动装箱)
    - [1.4.2. 自动拆箱:](#142-自动拆箱)
    - [1.4.3. 备注1:](#143-备注1)
    - [1.4.4. 备注2:](#144-备注2)
    - [1.4.5. 备注3:](#145-备注3)
- [2. 包装类中常用的操作方法](#2-包装类中常用的操作方法)
  - [2.1. 包装类中的常量](#21-包装类中的常量)
  - [2.2. 包装类的构造器](#22-包装类的构造器)
  - [2.3. 基本类型和包装类型的转换(装箱和拆箱)](#23-基本类型和包装类型的转换装箱和拆箱)
    - [2.3.1. 装箱](#231-装箱)
    - [2.3.2. 拆箱](#232-拆箱)
    - [2.3.3. 数据类型间的转换](#233-数据类型间的转换)
    - [2.3.4. String 和基本类型/包装类型之间的转换操作](#234-string-和基本类型包装类型之间的转换操作)
- [3. 包装类的缓存设计(享元模式)](#3-包装类的缓存设计享元模式)
- [4. 包装类型和基本类型的区别](#4-包装类型和基本类型的区别)
  - [4.1. 备注](#41-备注)

<!-- /TOC -->

## 1. 包装类的概念

### 1.1. 包装类的由来
基本数据类型缺少对象, 如果需要对象, 必须先有类.  
因此可以为每一个基本数据类型编写一个对应的包装类,  
类中包含基本类型的值和其对应的一些工具方法.

### 1.2. 基本数据类型及其包装类
八大基本数据类型的包装类都用 `final` 修饰  
不可被修改和继承

基本数据类型| 包装类
-|-
byte| Byte
short| Short
int| Integer
long| Long
char| Character
float| Float
double| Double
boolean| Boolean

### 1.3. 装箱和拆箱操作

#### 1.3.1. 装箱操作:  
  把一个基本类型的值转换为对应包装类对象.   
  - 示例:  
    ```java
    Integer num1 = new Integer(10);    
    Integer num2 = Integer.valueOf(10); 
    ```

#### 1.3.2. 拆箱操作:  
  把包装类的对象, 转换为对应的基本类型变量.  
  - 示例:  
    ```java
    int num3 = num1.intValue();
    ```

### 1.4. 自动装箱和自动拆箱
**由于在 java 集合框架中, 只能存储对象, 不能存储基本类型值**  
**而每次存储到集合中的基本数据类型都需要手动装箱, 会造成操作繁琐**  
**因此 Sun 公司从 java5 开始提供了自动装箱(Autobox)和自动拆箱(Auto)**  

#### 1.4.1. 自动装箱:  
  可以直接把一个基本类型值赋给对应的包装类对象  
  - 示例:  
    ```java
    Integer num4 = 10;
    ```

#### 1.4.2. 自动拆箱:  
  可以直接把一个包装类对象赋给对应的基本类型变量  
  - 示例:  
    ```java
    Integer num5 = 100;
    int num6 = num5;
    ```

#### 1.4.3. 备注1:  
  实际上自动装箱和拆箱只是编译器级别的新特性,  
  实际上底层封装的依旧是手动装箱和拆箱,  
  但是, 装箱操作使用的是 `Integer.valueOf` 的方式,  
  而非直接使用 `new Integer` 创建对象的方式.  

#### 1.4.4. 备注2:  
  有了自动装箱和拆箱的新特性之后,  
  `switch` 支持的数据类型也能支持包装类,  
  增加四个包装类, 为: `Byte, Short, Character, Integer`

#### 1.4.5. 备注3:  
  也由于这个新特性, `Object` 可以直接接受基本数据类型的值  
  因此 `Object` 在 java 中能表示一切数据类型.

## 2. 包装类中常用的操作方法

### 2.1. 包装类中的常量  
   - 最大值: `MAX_VALUE`
   - 最小值: `MIN_VALUE`
   - 内存中占的比特位数: `SIZE`
   - 对应的基本类型: `TYPE`
  
### 2.2. 包装类的构造器
- 第一种:  
  构造器参数中接收自己对应的基本类型值  
  如 `Integer(int val)`, `Boolean(bool val)`...
- 第二种:  
  构造器参数中接收的是 `String` 类型的值  
  但 `Character` 这个包装类除外, 它只有第一种构造器   
  如: `Integer(String val)`, `Boolean(String val)`...

### 2.3. 基本类型和包装类型的转换(装箱和拆箱)

#### 2.3.1. 装箱  
  - `Integer i1 = new Integer(111);`
  - `Integer i2 = Integer.valueOf(111);`
  - 推荐使用第二种, 因为这种方式带有缓存

#### 2.3.2. 拆箱  
  - `int val = i1;`

#### 2.3.3. 数据类型间的转换  
  - 由于 `Number` 类是 `Byte Short Long Integer Float` 和 `Double` 类的父类  
    因此, 这 6 个包装类都会从 `Number` 类中继承到一些方法  
    `Number` 类中带有这六种类型中任意包装类对象转换成任意基本数据类型的方法
  
  - 转换方法:  
  
    基本数据类型| 包装类对象调用的方法  
    -|-  
    byte| byteValue
    short| shortValue
    long| longValue
    int| intValue
    float| floatValue
    double| doubleValue

#### 2.3.4. String 和基本类型/包装类型之间的转换操作
不论用哪种方式进行转换, 输入的字符串必须能转换成数字!  
 - 把 `String` 转换为包装类对象
   - 方式 1:   
     `valueOf` 方法, 将 `String` 转换为对应的包装类对象  
     如: `Integer i1 = Integer.valueOf("123");`
   - 方式 2:  
     直接新建对象传参即可  
     如: `Integer i2 = new Integer("123");`
 - 把基本数据类型转换为 `String`
   - `String s1 = 18 + "";`
 - 把包装类对象转换为 `String`
   - `String str = 任何对象.toString();`
 - 把 `String` 转换为基本数据类型
   - `parseXXX` 方法, `XXX` 表示八大基本数据类型


## 3. 包装类的缓存设计(享元模式)
**在使用 valueOf 方法去创建包装类对象时会产生缓存**
- `Byte, Short, Integer, Long`:  
  缓存范围为 [-128, 127) 区间的数据.
- Character:  
  缓存[0, 127) 区间的数据

- 示例:  
  - 在缓存范围内, 创建相同值的对象会自动抓取缓存,  
    因此两次创建的对象是同一对象
    ```java
    Integer i1 = Integer.valueOf("123");
    Integer i2 = Integer.valueOf("123");
    System.out.println(i1==i2)// 结果为true
    ```
  - 在缓存范围外, 创建相同值的对象不会产生缓存,  
    因此两次创建的对象并非同一对象
    ```java
    Integer i3 = Integer.valueOf("270");
    Integer i4 = Integer.valueOf("270");
    System.out.println(i3==i4)// 结果为false
    ```
- 备注:  
  - 若要对超出缓存范围外的包装类对象数值进行比较  
    可使用 `equals` 方法.
    如: 
    ```java
    Integer i11 = 255;
    Integer i22 = 255;
    System.out.println(i11.equals(i22))// 结果为true
    ```
  - 因此包装类型对象间的比较操作一律建议使用 equals 方法进行比较,  
    因为比较的是包装的数据, 而非对象本身的地址.

## 4. 包装类型和基本类型的区别
1. 默认值:  
   包装类对象可以区分 `null` 和 `0`, 而基本类型变量不行,  
   如:  
   `int` 的默认值为 `0`, 而 `Integer` 的默认值为 `null`,  
   即 `Integer` 可以区分出未赋值和值为 `0` 的区别,  
   int 则无法表达出来未赋值的情况.

2. 操作方法:  
   包装类提供了很多与其基本类型相对应的方法,  
   如:  
   `Integer` 提供了多个与整数相关的操作方法,  
   `Integer` 中还定义表示整数的最大值和最小值的常量.

3. 集合中的存储:  
   集合中只能存储对象, 不能存储基本类型数据

4. 方法重载:  
   各自为参数时, 包装类对象和基本类型变量是不同类型的.

5. 存储位置:  
   在方法中, 基本类型变量存在栈中, 包装类对象存在堆中.  
   操作栈性能要高一些.

### 4.1. 备注
- 开发中建议使用包装类型