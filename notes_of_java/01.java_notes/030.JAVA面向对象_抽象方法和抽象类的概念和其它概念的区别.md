<!-- TOC -->

- [1. 抽象方法](#1-抽象方法)
  - [1.1. 定义:](#11-定义)
  - [1.2. 特点:](#12-特点)
  - [1.3. 备注:](#13-备注)
- [2. 抽象类](#2-抽象类)
  - [2.1. 定义:](#21-定义)
  - [2.2. 特点:](#22-特点)
  - [2.3. 总结:](#23-总结)
- [3. 抽象类和普通类的区别](#3-抽象类和普通类的区别)
- [4. 抽象类和多态的区别](#4-抽象类和多态的区别)
- [5. 抽象类中的构造器](#5-抽象类中的构造器)
- [6. 模板方法设计模式](#6-模板方法设计模式)

<!-- /TOC -->

## 1. 抽象方法

### 1.1. 定义:  
  - 使用 `abstract` 关键字修饰且没有方法体的方法, 称作抽象方法
    - 示例   
      如下所示, 在抽象类中定义了抽象方法.
      ```java
      abstract public class Test{
          abstract public void SayHi();
      }
      ```

### 1.2. 特点:  
  - 使用抽象 `abstract` 修饰, 方法没有方法体,  
    留给子类去实现, 且子类也必须要对其覆盖实现   
  
  - 抽象方法修饰符不能是 `private` 和 `final` 以及 `static`  
    因为抽象方法必须要被子类继承覆盖修改, 且供子类对象调用
  
  - 抽象方法必须定义在抽象类或接口中

### 1.3. 备注:  
  - 一般来说, 习惯性把 `abstract` 写在方法修饰符最前面

## 2. 抽象类

### 2.1. 定义:  
  - 使用 `abstract` 关键字修饰的类

### 2.2. 特点:  
  - 不能创建实例, 即不能创建抽象类对象  
    因为即使创建出抽象类对象, 也根本不能调用抽象方法,  
    因为抽象方法没有方法体
  
  - 可以不包含抽象方法, 若一旦包含, 该类必须作为抽象类  
    抽象类中可以存在普通方法, 是留给子类调用的.
  
  - 若子类没有实现父类所有抽象方法,  
    那么子类也得作为抽象类(抽象派生类)  
  
  - 构造方法都不能定义成私有的, 否则不能有子类,  
    因为创建子类对象前会先调用父类的构造方法
  
  - 抽象类不能被 `final` 修饰,  
    因为必须有子类, 抽象方法才能得以实现,   
    否则抽象类定义并无意义

### 2.3. 总结:  
  - 抽象类是不完整的类, 需要作为父类, 通过其子类才能实现它的功能, 因此没有子类的抽象类是没有意义的.
  
  - 一般抽象类起名都用 Abstract 作为名字前缀.
  
  - 抽象类中可以不存在抽象方法, 如此操作意义不大.   
    但可防止外界创建对象, 可作工具类使用.


## 3. 抽象类和普通类的区别
- 普通类有的成员(方法,字段,构造器), 抽象类都有
- 抽象类不能创建对象, 抽象类可以包含抽象方法

## 4. 抽象类和多态的区别
- 多态可以由父类创建对象, 实际可以指向它的子类,  
  使得由父类创建的对象可以根据实际使用时指向不同子类,  
  从而使用不同子类中的方法.

- 抽象类不可以由父类创建对象, 抽象类的实现必须通过子类.
  抽象方法实现必须通过具体的子类来创建对象从而调用方法.

## 5. 抽象类中的构造器
- 如果抽象类中存在构造器, 那么子类也会对其进行调用.  
  子类继承父类,会将父类的成员变量继承下来.  
  使用 `super` 调用父类构造的作用是初始化子类对象中继承自父类的属性.  
  而不是创建子类对象的同时也创建了一个父类对象

- 抽象类不能进行创建实例指的是不能直接调用抽象类的构造函数进行初始化对象.  
  - 例如存在抽象父类 `abstract public class Father{...}`,  
    假设其构造器为 `public Father(){...}`,  
    然后在创建实例的时候 `Father sample = new Father();`   
    这样创建是会报错的, 因为直接调用了父类构造函数, 是不合理的.  
  
  - 那么, 假设存在子类 `public class Son extends Father{...}`,  
    假设其构造器为 `public Son(){...}`,  
    然后在创建实例的时候 `Father sample = new Son();`  
    这样创建就不会报错, 因为调用的是子类的构造函数,  
    从而形成了抽象类的多态.

## 6. 模板方法设计模式
- 步骤  
  父类的方法中定义一个总体算法的骨架,  
  这个骨架在模板方法中实现,  
  然后将某一些步骤延迟到子类中去实现,  
  因为不同子类都会有不同的实现细节.
  这些实现细节继承抽象方法进行覆盖实现.
- 好处  
  模板方法是的子类可以在不改变算法结构的情况下  
  重新定义算法中的某些步骤
- 抽象父类至少提供的两种方法:  
  - 模板方法:  
    一种通用的处理方式, 即模板(算法骨架).  
    模板方法需要用 `final` 修饰, 子类不能篡改.
  - 抽象方法:  
    一种具体的业务功能实现, 由子类完成.  
    抽象方法可用 `protected` 修饰, 因为外界不需直接调用它
  - 备注:  
    抽象父类提供的模板方法只是定义了一个通用算法,  
    其实现必须依赖子类的辅助