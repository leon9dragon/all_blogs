<!-- TOC -->

- [1. 软件测试](#1-软件测试)
  - [1.1. 黑盒测试](#11-黑盒测试)
  - [1.2. 白盒测试](#12-白盒测试)
- [2. JUnit 单元测试](#2-junit-单元测试)
  - [2.1. JUnit 3](#21-junit-3)
    - [2.1.1. 环境搭建](#211-环境搭建)
  - [2.2. JUnit 4](#22-junit-4)
    - [2.2.1. 环境搭建](#221-环境搭建)
  - [2.3. 断言](#23-断言)
    - [2.3.1. 断言所用到的一些方法](#231-断言所用到的一些方法)

<!-- /TOC -->

## 1. 软件测试
- 软件测试分为两种: 黑盒测试和白盒测试.
- 其中单元测试是属于白盒测试的一种.

### 1.1. 黑盒测试
- 黑盒测试也称功能测试, 它是通过测试来检测每个功能是否都能正常使用.   
  这项测试通常由软件测试工程师进行.

- 在测试中, 把程序看作不能打开的黑盒子, 在完全不考虑程序内部结构和特性的情况下,   
  在程序接口进行测试. 它只检查程序功能是否按照需求规格说明书的规定正常使用,   
  程序是否能适当地接收输入数据而产生正确的输出信息. 

- 黑盒测试着眼于程序外部结构, 不考虑内部逻辑结构, 主要针对软件界面和功能进行测试. 

- 黑盒测试是以用户的角度, 从输入数据与输出数据的对应关系出发进行测试的.  
  所以, 如果外部特性本身设计有问题或规格说明的规定有误, 用黑盒测试是无效的.  
  因为只要程序按照设计的外部特性或规格说明进行输出, 那么黑盒测试就会通过.

- 黑盒测试法注重于测试软件的功能需求, 作用主要是试图发现下列几类错误:
  - 功能不正确或遗漏;
  - 界面错误;
  - 输入和输出错误;
  - 数据库访问错误;
  - 性能错误;
  - 初始化和终止错误等;

****

### 1.2. 白盒测试
- 白盒测试又称结构测试/透明盒测试/逻辑驱动测试/基于代码的测试.  
  这项测试通常由软件开发工程师进行.

- 它是按照程序内部的结构测试程序, 通过测试来检测产品内部动作是否按照  
  设计规格说明书的规定正常进行, 检验程序中的每条通路是否都能按预定要求正确工作.   

- 这一方法是把测试对象看作一个打开的盒子, 测试人员依据程序内部逻辑结构相关信息,  
  设计或选择测试用例, 对程序所有逻辑路径进行测试, 通过在不同点检查程序的状态,   
  确定实际的状态是否与预期的状态一致.  

- 白盒测试是一种测试用例设计方法, 盒子指的是被测试的软件, 白盒指的是  
  测试员可视的并清楚盒子内部结构以及盒子里面的运作原理的盒子. 

- "白盒"法全面了解程序内部逻辑结构, 对所有逻辑路径进行测试.   
  测试者必须检查程序的内部结构, 从检查程序的逻辑着手, 得出测试数据.

****

## 2. JUnit 单元测试
- Java 的单元测试: Junit, 存在两个版本:
  - junit3.x:   
    针对于 Java5 之前的版本，没有注解, 得按照规范来写测试, Android 中使用 junit3.x.

  - junit4.x:  
    针对于 Java5 以及之后的版本, 使用注解, 推荐.

****

### 2.1. JUnit 3

#### 2.1.1. 环境搭建

- 使用 junit3.x 步骤:
  - 把 junit3.x 的测试 jar 包添加到该项目中来.
  - 定义一个测试类, 并让该测试类继承 TestCase 类. 测试类的名字: `XXXTest`.
  - 定义 `XXXDAOTest` 测试类并在其中编写测试方法, 如:  
    ```java
    public void testXXX() throws Exception {}
    ```
  - 注意:  
    方法是 public 修饰的，无返回的必须以 test 作为方法前缀, xxx 表示测试功能的名字.

  - 选择某一个测试方法,鼠标右键选择 `[run as junit]`,  
    或选中测试类表示测试该类中所有的测试方法.

- 补充事项:
  - 若要在测试方法之前做准备操作:   
    覆写从 TestCase 继承的 `protected void setUp() throws Exception` 方法

  - 若要在测试方法之后做回收操作:  
    覆写从 TestCase 继承的 `protected void tearDown() throws Exception` 方法

  - 执行顺序:   
    setUp -> 测试方法 -> tearDown -> 若有多个方法则继续循环... -> setUp -> ...

****

### 2.2. JUnit 4

#### 2.2.1. 环境搭建
- 使用 junit4.x步骤:
  - 把 junit4.x 的测试 jar 包添加到该项目中来;
  - 定义一个测试类(不再继承TestCase类)
    测试类的名字: XXXTest
  - 在 XXXTest 中编写测试方法, 如:
    ```java
    @Test
    public void testXXX() throws Exception {}
    ```
  - 注意:  
    方法是 public 修饰的无返回的, 且必须贴有 `@Test` 标签, XXX 表示测试功能名字.
  
  - 选择某一个测试方法,鼠标右键选择 `[run as junit]`,  
    或选中测试类表示测试该类中所有的测试方法.  

- 补充说明:  
  - 若要在测试方法之前做准备操作:  
    测试类中随意定义一个方法并使用 `@Before` 标注:
    ```java
    @Before
    public void xx() throws Exception
    ```

  - 若要在测试方法之后做回收操作:  
    测试类中随意定义一一个方法并使用 `@After` 标注:
    ```java
    @After
    public void xx() throws Exception
    ```
  - 特点:  
    - 每次执行测试 Test 方法之前都会执行 Before 方法;
    - 每次执行测试 Test 方法之后都会执行 After 方法;



- 最初只初始化一次和最终只销毁一次的标签:  
  - `@BeforeClass` 标签:  
    在所有的 Before 方法之前执行, 只在最初执行一次. 只能修饰静态方法.  
  
  - `@AfterClass` 标签:  
    在所有的 After 方法之后执行, 只在最后执行一次. 只能修饰静态方法.  

- 执行顺序:  
  BeforeClass -> (Before -> Test -> After [测试方法若有多个则循环这一段]) -> AfterClass

****

### 2.3. 断言
- 使用断言方式做单元测试:
  - 期望值: 根据设计逻辑所预期得出的结果值.
  - 真实值: 实际程序内部运算后的真实结果值.
  - 断言成功: 期望值和真实值相同, 此时显示绿条.
  - 断言失败: 期望值和真实值不同, 此时显示红条.

- 通常来说是在测试类中建立一个私有对象, 对象属于被测试的目标类,   
  然后通过这个对象调用目标类中的方法, 来获取返回值.  
  同时获取的返回值根据返回类型存放在变量当中, 然后传入断言方法中,  
  作为真实值来作为参数来调用断言方法.

#### 2.3.1. 断言所用到的一些方法
- `Assert.assertEquals(message, expected, actual)`:
  - 三个参数:
    - message: 断言失败的提示信息(断言成功不会显示)
    - expected: 期望值(根据设计逻辑所预期出现的结果值)
    - actual: 真实值 (实际调用方法的返回值, 若和期望值想等，则断言成功)

- `Assert.assertSame(message, expected, actual)`: 比较地址，是同一个对象  
  `Assert.assertNotSame(message, expected, actual)`: 断言不是同一个对象

- `Assert.assertTrue(message, condition}`: 断言 condition 应该为 TRUE.

- `AssertassertFalse(message, condition)`: 断言 condition 应该为 FALSE.

- `AssertassertNull(message, object)`: 断言对象 object 为 null.

- `AssertassertNotNul(message, object)`: 断言对象 object 不为 null.

- `@Test(expected = ArithmeticException.class)`: 期望该方法报错 ArithmeticException.

- `@Test(timeout = 400)`: 期望该方法在400毫秒之内执行完成