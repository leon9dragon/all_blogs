<!-- TOC -->

- [1. 反射机制](#1-反射机制)
  - [1.1. 反射的概述](#11-反射的概述)
    - [1.1.1. 反射的概念](#111-反射的概念)
    - [1.1.2. 反射的必要性](#112-反射的必要性)
    - [1.1.3. 反射的优缺点](#113-反射的优缺点)
    - [1.1.4. 反射的用途](#114-反射的用途)
    - [1.1.5. 反射常用的类](#115-反射常用的类)

<!-- /TOC -->

## 1. 反射机制

### 1.1. 反射的概述

#### 1.1.1. 反射的概念
- 反射机制允许程序在运行时取得任何一个已知名称的 `class` 的内部信息,  
  包括包括其 `modifiers`(修饰符), `fields`(属性), `methods`(方法)等,  
  并可于运行时改变 `fields` 内容或调用 `methods`.

- 本质是 JVM 得到 class 对象之后, 再通过 class 对象进行反编译,  
  从而获取对象的各种信息.

#### 1.1.2. 反射的必要性
- Java 属于先编译再运行的语言, 程序中对象的类型在编译期就确定下来了.  

- 而当程序在运行时可能需要动态加载某些类, 因为这些类之前并没有用到,  
  所以并没有被加载到 JVM 中, 因此有时候调用的方法所返回的对象,  
  如果是对象所属的类是未加载的类, 就有可能会出现未引入类的异常.  
  
- 通过使用反射, 便可在运行时动态地创建对象并调用其属性,  
  不需要提前在编译期确定运行的对象的所属的类是什么.

#### 1.1.3. 反射的优缺点
- 优点:
  - 可让代码编写更灵活, 让代码可以在运行时装配 . 
  - 让代码无需在组件之间进行源代码链接, 降低了耦合度;  
  - 还可用于动态代理的实现等等. 

- 缺点: 
  - 反射所占用的资源比较高, 需要合理的去安排.  
    如果不需要动态地创建一个对象, 那就不需要用反射.  
  - 反射调用方法时可以忽略权限检查, 可能会破坏封装导致安全问题.

#### 1.1.4. 反射的用途
- 反编译:  
  将字节码文件进行反编译从而取得源码文件, `.class -->.java`.

- 获取类中的信息:  
  通过反射机制访问 java 对象的属性, 方法, 构造方法等.

- 编译器的智能提示:  
  当我们在使用 IDE, 比如 Ecplise 时, 当我们输入一个对象或者类,  
  并想调用他的属性和方法时, 编译器就会自动列出他的属性或者方法,  
  这里就是用到反射. 

- 开发各种通用框架(最重要的应用):     
  很多框架(比如 Spring)都是配置化的(比如通过XML文件配置Bean),   
  为了保证框架的通用性, 可能需要根据配置文件加载不同的类或对象, 调用不同的方法,   
  这个时候必须使用反射, 运行时动态加载需要的加载的对象. 

#### 1.1.5. 反射常用的类
- `java.lang.Class<T>`:  
  `Class` 类的实例表示正在运行的 Java 应用程序中的类和接口.

- `java.lang.reflect.Constructor<T>`:   
  `Constructor` 提供关于类的单个构造方法的信息以及对它的访问权限.
  

- `java.lang.reflect.Method`:   
  `Method` 提供关于类或接口上单独某个方法(以及如何访问该方法)的信息.

- `java.lang.reflect.Field`:   
  `Field` 提供有关类或接口的单个字段的信息, 以及对它的动态访问权限.
  